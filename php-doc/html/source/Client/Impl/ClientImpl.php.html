<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
declare(ticks=1);
/**
 * TCP Client implementation for AMI.
 *
 * PHP Version 5
 *
 * @category   Pami
 * @package    Client
 * @subpackage Impl
 * @author     Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 * @license    http://marcelog.github.com/PAMI/ Apache License 2.0
 * @version    SVN: $Id$
 * @link       http://marcelog.github.com/PAMI/
 *
 * Copyright 2011 Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
namespace PAMI\Client\Impl;

use PAMI\Message\OutgoingMessage;
use PAMI\Message\Message;
use PAMI\Message\IncomingMessage;
use PAMI\Message\Action\LoginAction;
use PAMI\Message\Action\LogoffAction;
use PAMI\Message\Response\ResponseMessage;
use PAMI\Message\Event\EventMessage;
use PAMI\Message\Event\Factory\Impl\EventFactoryImpl;
use PAMI\Listener\IEventListener;
use PAMI\Client\Exception\ClientException;
use PAMI\Client\IClient;

/**
 * TCP Client implementation for AMI.
 *
 * PHP Version 5
 *
 * @category   Pami
 * @package    Client
 * @subpackage Impl
 * @author     Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 * @license    http://marcelog.github.com/PAMI/ Apache License 2.0
 * @link       http://marcelog.github.com/PAMI/
 */
class ClientImpl implements IClient
{
    /**
     * log4php logger or dummy.
     * @var Logger
     */
    private $_logger;

    /**
     * Hostname
     * @var string
     */
	private $_host;

	/**
	 * TCP Port.
	 * @var integer
	 */
	private $_port;

	/**
     * Username
     * @var string
     */
	private $_user;

	/**
     * Password
     * @var string
     */
	private $_pass;

	/**
	 * Connection timeout, in seconds.
	 * @var integer
	 */
	private $_cTimeout;

	/**
	 * Connection scheme, like tcp:// or tls://
	 * @var string
	 */
	private $_scheme;

	/**
	 * Event factory.
	 * @var EventFactoryImpl
	 */
	private $_eventFactory;

	/**
	 * R/W timeout, in milliseconds.
	 * @var integer
	 */
	private $_rTimeout;

	/**
	 * Our stream socket resource.
	 * @var resource
	 */
	private $_socket;

	/**
	 * Our stream context resource.
	 * @var resource
	 */
	private $_context;

	/**
	 * Our event listeners
	 * @var IEventListener[]
	 */
	private $_eventListeners;

	/**
	 * The send queue
	 * @var OutgoingMessage[]
	 */
	private $_outgoingQueue;

	/**
	 * The receiving queue.
	 * @var IncomingMessage[]
	 */
	private $_incomingQueue;

	/**
	 * Our current received message. May be incomplete, will be completed
	 * eventually with an EOM.
	 * @var string
	 */
	private $_currentProcessingMessage;

	/**
	 * This should not happen. Asterisk may send responses without a
	 * corresponding ActionId.
	 * @var string
	 */
	private $_lastActionId;

	/**
	 * Opens a tcp connection to ami.
	 *
	 * @throws ClientException
	 * @return void
	 */
	public function open()
	{
		$cString = $this-&gt;_scheme . $this-&gt;_host . ':' . $this-&gt;_port;
		$this-&gt;_context = stream_context_create();
		$errno = 0;
		$errstr = '';
		$this-&gt;_socket = @stream_socket_client(
			$cString, $errno, $errstr,
			$this-&gt;_cTimeout, STREAM_CLIENT_CONNECT, $this-&gt;_context
		);
		if ($this-&gt;_socket === false) {
			throw new ClientException('Error connecting to ami: ' . $errstr);
		}
		//stream_set_timeout($this-&gt;_socket, 0, $this-&gt;_rTimeout * 1000);
	    $msg = new LoginAction($this-&gt;_user, $this-&gt;_pass);
	    $id = $this-&gt;getLine();
	    if (strstr($id, 'Asterisk') === false) {
	        throw new ClientException('Unknown peer. Is this an ami?: ' . $id);
	    }
	    $response = $this-&gt;send($msg);
	    if (!$response-&gt;isSuccess()) {
	        throw new ClientException('Could not connect: ' . $response-&gt;getMessage());
	    }
	    stream_set_blocking($this-&gt;_socket, 0);
	    $this-&gt;_currentProcessingMessage = '';
	    //register_tick_function(array($this, 'process'));
	    if ($this-&gt;_logger-&gt;isDebugEnabled()) {
	        $this-&gt;_logger-&gt;debug('Logged in successfully to ami.');
	    }
	}

	/**
	 * Registers the given listener so it can receive events. Returns the generated
	 * id for this new listener.
	 *
	 * @param IEventListener $listener
	 *
	 * @return string
	 */
	public function registerEventListener(IEventListener $listener)
	{
	    $id = uniqid('PamiListener');
	    $this-&gt;_eventListeners[$id] = $listener;
	    return $id;
	}

	/**
	 * Unregisters an event listener.
	 *
	 * @param string $id The id returned by registerEventListener.
	 *
	 * @return void
	 */
	public function unregisterEventListener($id)
	{
	    if (isset($this-&gt;_eventListeners[$id])) {
	        unset($this-&gt;_eventListeners[$id]);
	    }
	}
	/**
	 * Reads a line over the stream until EOL.
	 *
	 * @return string
	 */
	protected function getLine()
	{
        return stream_get_line($this-&gt;_socket, 1024, Message::EOL);
	}

	/**
	 * Reads a complete message over the stream until EOM.
	 *
	 * @return string
	 */
	protected function getMessages()
	{
	    $msgs = array();
	    // Read something.
	    $read = fread($this-&gt;_socket, 65535);
	    if ($read === false) {
	        throw new ClientException('Error reading');
	    }
	    $this-&gt;_currentProcessingMessage .= $read;
	    // If we have a complete message, then return it. Save the rest for
	    // later.
	    while (($marker = strpos($this-&gt;_currentProcessingMessage, Message::EOM))) {
    	    $msg = substr($this-&gt;_currentProcessingMessage, 0, $marker);
    	    $this-&gt;_currentProcessingMessage = substr(
    	        $this-&gt;_currentProcessingMessage, $marker + strlen(Message::EOM)
    	    );
    	    $msgs[] = $msg;
	    }
	    return $msgs;
	}

	/**
	 * Main processing loop. Also called from send(), you should call this in
	 * your own application in order to continue reading events and responses
	 * from ami. You may also declare(ticks=1) in your main source code.
	 *
	 * Taken from: http://www.voip-info.org/wiki/view/Asterisk+manager+API
	 *
	 * The type of a packet is determined by the existence of one of the
	 * following keys:
	 * Action: A packet sent by the connected client to Asterisk, requesting a
	 * particular Action be performed. There are a finite (but extendable) set
	 * of actions available to the client, determined by the modules presently
	 * loaded in the Asterisk engine. Only one action may be outstanding at a
	 * time. The Action packet contains the name of the operation to be
	 * performed as well as all required parameters.
	 * Response: the response sent by Asterisk to the last action sent by the
	 * client.
	 * Event: data pertaining to an event generated from within the Asterisk
	 * core or an extension module.
	 * Generally the client sends Action packets to the Asterisk server, the
	 * Asterisk server performs the requested operation and returns the result
	 * (often only success or failure) in a Response packet. As there is no
	 * guarantee regarding the order of Response packets the client usually
	 * includes an ActionID parameter in every Action packet that is sent back
	 * by Asterisk in the corresponding Response packet. That way the client
	 * can easily match Action and Response packets while sending Actions at
	 * any desired rate without having to wait for outstanding Response packets
	 * before sending the next action.
	 * Event packets are used in two different contexts: On the one hand they
	 * inform clients about state changes in Asterisk (like new channels being
	 * created and hung up or agents being logged in and out) on the other hand
	 * they are used to transport the response payload for actions that return
	 * a list of data (event generating actions). When a client sends an event
	 * generating action Asterisk sends a Response packed indicating success
	 * and containing a &quot;Response: Follows&quot; line. Then it sends zero or more
	 * events that contain the actual payload and finally an action complete
	 * event indicating that all data has been sent. The events sent in
	 * response to an event generating action and the action complete event
	 * contain the ActionID of the Action packet that triggered them, so you
	 * can easily match them the same way as Response packets. An example of an
	 * event generating action is the Status action that triggers Status events
	 * for each active channel. When all Status events have been sent a
	 * terminating a StatusComplete event is sent.
	 *
	 * @todo not suitable for multithreaded applications.
	 *
	 * @return void
	 */
	public function process()
	{
	    $msgs = $this-&gt;getMessages();
	    foreach ($msgs as $aMsg) {
    	    if ($this-&gt;_logger-&gt;isDebugEnabled()) {
       	        $this-&gt;_logger-&gt;debug(
    	        	'------ Received: ------ ' . &quot;\n&quot; . $aMsg . &quot;\n\n&quot;
    	        );
    	    }
    	    $resPos = strpos($aMsg, 'Response:');
    	    $evePos = strpos($aMsg, 'Event:');
    	    if (($resPos !== false) &amp;&amp; (($resPos &lt; $evePos) || $evePos === false)) {
    	        $response = $this-&gt;_messageToResponse($aMsg);
                $this-&gt;_incomingQueue[$response-&gt;getActionId()] = $response;
    	    } else if ($evePos !== false) {
    	        $event = $this-&gt;_messageToEvent($aMsg);
        	    $response = $this-&gt;findResponse($event);
        	    if ($response === false) {
                    $this-&gt;dispatch($event);
        	    } else {
        	        $response-&gt;addEvent($event);
        	    }
    	    } else { // broken ami.. sending a response with events without Event and ActionId
                $bMsg = 'Event: ResponseEvent' . &quot;\r\n&quot;;
                $bMsg .= 'ActionId: ' . $this-&gt;_lastActionId . &quot;\r\n&quot; . $aMsg;
                $event = $this-&gt;_messageToEvent($bMsg);
                $response = $this-&gt;findResponse($event);
                $response-&gt;addEvent($event);
    	    }
    	    if ($this-&gt;_logger-&gt;isDebugEnabled()) {
       	        $this-&gt;_logger-&gt;debug('----------------');
    	    }
	    }
	}

	/**
	 * Tries to find an associated response for the given message.
	 *
	 * @param IncomingMessage $message Message sent by asterisk.
	 *
	 * @return ResponseMessage
	 */
	protected function findResponse(IncomingMessage $message)
	{
	    $actionId = $message-&gt;getActionId();
        if (isset($this-&gt;_incomingQueue[$actionId])) {
            return $this-&gt;_incomingQueue[$actionId];
        }
        return false;
	}

	/**
	 * Dispatchs the incoming message to a handler.
	 *
	 * @param IncomingMessage $message Message to dispatch.
	 *
	 * @return void
	 */
	protected function dispatch(IncomingMessage $message)
	{
        foreach ($this-&gt;_eventListeners as $listener) {
            $listener-&gt;handle($message);
        }
	}

	/**
	 * Returns a ResponseMessage from a raw string that came from asterisk.
	 *
	 * @param string $msg Raw string.
	 *
	 * @return ResponseMessage
	 */
	private function _messageToResponse($msg)
	{
        $response = new ResponseMessage($msg);
	    $actionId = $response-&gt;getActionId();
	    if ($actionId === null) {
	        $actionId = $this-&gt;_lastActionId;
	        $response-&gt;setActionId($this-&gt;_lastActionId);
	    }
	    return $response;
	}

	/**
	 * Returns a EventMessage from a raw string that came from asterisk.
	 *
	 * @param string $msg Raw string.
	 *
	 * @return EventMessage
	 */
	private function _messageToEvent($msg)
	{
        return $this-&gt;_eventFactory-&gt;createFromRaw($msg);
	}

	/**
	 * Returns a message (response) related to the given message. This uses
	 * the ActionID tag (key).
	 *
	 * @todo not suitable for multithreaded applications.
	 *
	 * @return IncomingMessage
	 */
	protected function getRelated(OutgoingMessage $message)
	{
	    $ret = false;
	    $id = $message-&gt;getActionID('ActionID');
	    if (isset($this-&gt;_incomingQueue[$id])) {
	        $response = $this-&gt;_incomingQueue[$id];
	        if ($response-&gt;isComplete()) {
    	        unset($this-&gt;_incomingQueue[$id]);
	            $ret = $response;
	        }
	    }
	    return $ret;
	}

	/**
	 * Sends a message to ami.
	 *
	 * @param OutgoingMessage $message Message to send.
	 *
	 * @see ClientImpl::send()
	 * @throws ClientException
	 * @return void
	 */
	public function send(OutgoingMessage $message)
	{
	    $messageToSend = $message-&gt;serialize();
	    $length = strlen($messageToSend);
	    if ($this-&gt;_logger-&gt;isDebugEnabled()) {
	        $this-&gt;_logger-&gt;debug(
	        	'------ Sending: ------ ' . &quot;\n&quot; . $messageToSend . '----------'
	        );
        }
	    $this-&gt;_lastActionId = $message-&gt;getActionId();
	    if (fwrite($this-&gt;_socket, $messageToSend) &lt; $length) {
    	    throw new ClientException('Could not send message');
	    }
	    /**
	     * @todo this should not be an infinite loop. Check read timeout.
	     */
	    $read = 0;
	    while($read &lt;= $this-&gt;_rTimeout) {
	        $this-&gt;process();
	        $response = $this-&gt;getRelated($message);
	        if ($response != false) {
	            $this-&gt;_lastActionId = false;
	            return $response;
	        }
	        usleep(1000); // 1ms delay
	        if ($this-&gt;_rTimeout &gt; 0) {
	            $read++;
	        }
	    }
	    throw new ClientException('Read timeout');
	}

	/**
	 * Closes the connection to ami.
	 *
	 * @return void
	 */
	public function close()
	{
	    if ($this-&gt;_logger-&gt;isDebugEnabled()) {
	        $this-&gt;_logger-&gt;debug('Closing connection to asterisk.');
	    }
	    $this-&gt;send(new LogoffAction());
		stream_socket_shutdown($this-&gt;_socket, STREAM_SHUT_RDWR);
	}

	/**
	 * Constructor.
	 *
	 * @param string[] $options Options for ami client.
	 *
	 * @return void
	 */
	public function __construct(array $options)
	{
        if (isset($options['log4php.properties'])) {
            \Logger::configure($options['log4php.properties']);
        }
        $this-&gt;_logger = \Logger::getLogger('Pami.ClientImpl');
	    $this-&gt;_host = $options['host'];
		$this-&gt;_port = intval($options['port']);
		$this-&gt;_user = $options['username'];
		$this-&gt;_pass = $options['secret'];
		$this-&gt;_cTimeout = $options['connect_timeout'];
		$this-&gt;_rTimeout = $options['read_timeout'];
		$this-&gt;_scheme = isset($options['scheme']) ? $options['scheme'] : 'tcp://';
		$this-&gt;_eventListeners = array();
		$this-&gt;_eventFactory = new EventFactoryImpl();
		$this-&gt;_incomingQueue = array();
		$this-&gt;_lastActionId = false;
	}
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>